import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from config import config
from CNN_ActionPrediction import actionPrediction
from LSTM_Model import mixed_Predicted_Price

# uncomment if using IDE
_, _, _, pt_pred, _, multi_df, _ = mixed_Predicted_Price()
stock_proportion, stock_price = actionPrediction()


# # uncomment if using colab
# stock_proportion, stock_price = y_pred, daily_close_test
# pt_pred, seq_pred, multi_df = pt_df, seq_df, multi_df

pt_pred = pt_pred[pt_pred.index.isin(stock_price.index)]
multi_pred = multi_df[multi_df.index.isin(stock_price.index)]

# first day stock price
init_price = stock_price.iloc[0].values

start_date = 0
final_date = stock_price.shape[0] - 1


class Environment():
    """ define the stock exchange environment """

    def __init__(self):
        """ Initialize the environment """

        self.init_price = init_price
        self.curr_price = self.init_price

        self.init_assets = config.init_assets
        self.curr_assets = self.init_assets

        self.init_proportion = np.array(
            [1 / config.n_stock for _ in config.tickers])
        self.curr_proportion = self.init_proportion

        self.init_share = config.init_assets * self.init_proportion / init_price
        self.curr_share = self.init_share

        self.reward = 0.0
        self.init_timestep = start_date
        self.timestep = self.init_timestep

        self.terminal = (final_date or self.curr_assets <= 0)
        self.is_done = False

    def reset(self):
        """ Reset the game environmet """

        self.curr_price = self.init_price
        self.curr_assets = self.init_assets
        self.curr_proportion = self.init_proportion
        self.curr_share = self.init_share

        self.reward = 0.0
        self.timestep = self.init_timestep
        self.is_done = False

        return self.timestep

    def step(self, action):  # hold or buy
        """ update after take an action """

        curr_price = self.curr_price
        curr_prop = self.curr_proportion
        curr_assets = self.curr_assets
        curr_share = self.curr_share

        pred_prop = stock_proportion[self.timestep + 1]

        # uncomment one price prediction code
        # pred_price = pt_pred.iloc[self.timestep + 1].values
        pred_price = multi_pred.iloc[self.timestep + 1].values

        if not action:
            cost = 0
            self.curr_assets = np.sum(curr_share * curr_price)
            self.curr_share = curr_share

        else:
            self.curr_assets = np.sum(curr_share * curr_price)
            cost = config.transaction_cost * self.curr_assets
            self.curr_share = self.curr_assets * pred_prop / pred_price

        price_change = (pred_price - curr_price)
        profit = np.sum(curr_assets * price_change) - cost

        self.curr_price = stock_price.iloc[self.timestep].values
        self.reward = profit
        self.is_done = (self.timestep + 1 == final_date)
        self.timestep += 1

        return self.timestep, self.curr_price, self.curr_assets, self.reward, self.is_done


def greedy_policy(q_values, epsilon=0.2):
    """ choose the action generated by CNN model """
    if np.random.binomial(1, epsilon) == 1:
        return np.random.choice([0, 1])
    else:
        return np.random.choice([action_ for action_, value_ in enumerate(
            q_values) if value_ == np.max(q_values)])

    return act_


def Sarsa(qsa, next_qsa, r, alpha=0.1, gamma=1.0):
    return qsa + alpha * (r + gamma * next_qsa - qsa)


def RL_main():
    """ reinforcement learning main function """

    env = Environment()
    sqa = np.zeros((1, 1, 2))
    assets = [[] for _ in range(config.RL_episode)]

    for epi in range(config.RL_episode):
        ts = env.reset()
        is_done = False

        a_ = greedy_policy(sqa[0, 0, :])

        while not is_done:
            ts_, p_, ass_, r_, is_done = env.step(a_)
            assets[epi].append(ass_)

            # choose an action for the next start
            a_n = greedy_policy(sqa[0, 0, :])

            # Sarsa update
            sqa[0, 0, a_] = Sarsa(sqa[0, 0, a_], sqa[0, 0, a_n], r_)

            ts = ts_
            a_ = a_n

    return assets


# Run RL 3 times: for assect predictoin with pt_pred, seq_pred, multi_pred
pt_assets = RL_main()
multi_assets = RL_main()

assets_pd = pd.DataFrame([np.mean(np.array(pt_assets), axis=0),
                          np.mean(np.array(multi_assets), axis=0)],
                         index=["pt_pred", "multi_pred"],
                         columns=pt_pred.index[:-1]).T

# plot the assets
plt.figure(figsize=(18, 6))
plt.plot(assets_pd)
plt.legend(labels=assets_pd.columns)
plt.title("Assets: LSTM Price & Proportion Prediction")
plt.show()
